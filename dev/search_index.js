var documenterSearchIndex = {"docs":
[{"location":"examples/multifuncs.html#Interfaces-with-multiple-functions","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"","category":"section"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"Most interfaces are larger than just a single function, requiring multiple methods to be implemented in order to conform to the interface. One example for this is AbstractArray, which at minimum (for linear indexing) requires these methods to be implemented:","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"size(::AbstractArray)\ngetindex(::AbstractArray, i::Int)","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"This interface can be described like so:","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"using RequiredInterfaces\nconst RI = RequiredInterfaces\n\nabstract type LinearArray{T,N} <: AbstractArray{T,N} end\n@required LinearArray begin\n    Base.size(::LinearArray)\n    Base.getindex(::LinearArray, ::Int)\nend","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"Importantly, we don't need to subtype LinearArray in order to check whether a type would implement the interface:","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"using Test\n@test RI.check_interface_implemented(LinearArray, Vector)","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"At the moment, this doesn't handle fallback definitions of abstract types well - for example, if we do the same check with Array, which has a fallback size defined:","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"using Test\n@test RI.check_interface_implemented(LinearArray, Array)","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"While unfortunate, this is only a limitation of the current implementation, and should be remedied in the future.","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"Another limitation is that we can't use LinearArray to dispatch Array objects, due to Julia not recognizing that the concrete instantiations of Array (Vector etc.) do implement the interface correctly - this is something that could be remedied with the solution presented in About Interfaces, though there are multiple other venues as well.","category":"page"},{"location":"examples/multifuncs.html","page":"Interfaces with multiple functions","title":"Interfaces with multiple functions","text":"For now, checks like these can serve as information on whether a type does conform to the interface correctly, even if it doesn't formally subtype the abstract type behind this interface.","category":"page"},{"location":"api.html#Function-Index","page":"API Reference","title":"Function Index","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api.html#Function-reference","page":"API Reference","title":"Function reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [RequiredInterfaces]\nOrder = [:macro, :function, :type]","category":"page"},{"location":"api.html#RequiredInterfaces.@required-Tuple{Symbol, Expr}","page":"API Reference","title":"RequiredInterfaces.@required","text":"@required MyInterface func(::Foo, ::MyInterface)\n@required MyInterface function func(::Foo, ::MyInterface) end\n@required MyInterface begin\n    foo(::B, ::MyInterface)\n    bar(::A, ::MyInterface)\nend\n\nMarks all occurences of MyInterface in the given function signatures as part of the interface MyInterface. Also defines fallback methods, which throw a NotImplementedError when called with an argument that doesn't implement this mandatory function.\n\nThrows an ArgumentError if MyInterface is not an abstract type or the given expression doesn't conform to the three shown styles. The function body of the second style is expected to be empty - @required can't be used to mark fallback implementations as part of a user-implementable interface. Its sole purpose is marking parts of an API that a user needs to implement to be able to have functions expecting that interface work.\n\n\n\n\n\n","category":"macro"},{"location":"api.html#RequiredInterfaces.functions-Tuple{RequiredInterfaces.Interface}","page":"API Reference","title":"RequiredInterfaces.functions","text":"functions(i::Interface)\n\nReturns the functions that are required by this interface.\n\n\n\n\n\n","category":"method"},{"location":"api.html#RequiredInterfaces.getInterface","page":"API Reference","title":"RequiredInterfaces.getInterface","text":"getInterface(::Type{T}) -> Interface\n\nReturn the Interface described by  the type T.\n\nThrows a MethodError if the given type is not a registered interface.\n\n\n\n\n\n","category":"function"},{"location":"api.html#RequiredInterfaces.interfaceType-Tuple{RequiredInterfaces.Interface}","page":"API Reference","title":"RequiredInterfaces.interfaceType","text":"interfaceType(i::Interface)\n\nReturn the (abstract) type associated with this interface.\n\n\n\n\n\n","category":"method"},{"location":"api.html#RequiredInterfaces.isInterface-Tuple{Any}","page":"API Reference","title":"RequiredInterfaces.isInterface","text":"isInterface(::Type{T}) -> Bool\n\nReturn whether the given (abstract) type is a recognized interface.\n\nThrows an ArgumentError if the given type is not a registered interface.\n\n\n\n\n\n","category":"method"},{"location":"api.html#RequiredInterfaces.methods-Tuple{RequiredInterfaces.Interface}","page":"API Reference","title":"RequiredInterfaces.methods","text":"methods(i::Interface)\n\nReturn the methods (i.e., functions and their signatures) required to be implemented by this interface.\n\nSee also functions.\n\n\n\n\n\n","category":"method"},{"location":"api.html#RequiredInterfaces.Interface","page":"API Reference","title":"RequiredInterfaces.Interface","text":"Interface\n\nA struct describing the notion of an (abstract-)type-based interface.\n\n\n\n\n\n","category":"type"},{"location":"api.html#RequiredInterfaces.NotImplementedError","page":"API Reference","title":"RequiredInterfaces.NotImplementedError","text":"NotImplementedError(interface::String, method::String) <: Exception\n\nDescribes that a given method (in form of a String describing the signature) that's part of the given interface has not been implemented.\n\nThe given method should have the form method(..., ::T, ...), where ... are other arguments. The message displayed by this Exception refers to T directly, so there's no need to give any particular subtype here.\n\nCompared to MethodError, a NotImplementedError communicates \"there should be a method to call here, but it needs to be implemented by the developer making use of the interface\". This is mostly used through the @required macro, which handles the message generation for you.\n\nExamples\n\nNote how MethodError in the example below indicates that the method isn't intended to be called.\n\njulia> using RequiredInterfaces: NotImplementedError\n\njulia> abstract type Foo end\n\njulia> bar(::Foo, ::Int) = throw(NotImplementedError(\"Foo\", \"bar(::T, ::Int)\"))\nbar (generic function with 1 method)\n\njulia> struct Baz <: Foo end\n\njulia> bar(Baz(), 1)\nERROR: NotImplementedError: The called method is part of a fallback definition for the `Foo` interface.\nPlease implement `bar(::T, ::Int)` for your type `T <: Foo`.\nStacktrace:\n [1] bar(::Baz, ::Int64)\n   @ Main ./none:1\n [2] top-level scope\n   @ none:1\n\njulia> bar(1, Baz())\nERROR: MethodError: no method matching bar(::Int64, ::Baz)\nThe function `bar` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  bar(!Matched::Foo, !Matched::Int64)\n   @ Main none:1\n\nStacktrace:\n [1] top-level scope\n   @ none:1\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#About-Interfaces","page":"About Interfaces","title":"About Interfaces","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"This package is built around the assumption that an abstract type describes an informal interface. In this page, we're going to look at why I think this is the expected interpretation for what an abstract type is, as well as what this means for the (possible) future of interfaces and traits.","category":"page"},{"location":"interfaces.html#Types-in-Julia","page":"About Interfaces","title":"Types in Julia","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Before we get into the semantic meaning of abstract types, it's good to establish a baseline about the kinds of types we have in Julia as part of the user facing API (deliberately NOT what the compiler internally uses!), how they relate to each other and what ought to hold in these relations.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"So, these are the basic kinds of types Julia knows about:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract types\ne.g. Integer or Real\nThis also includes the Any type\nstruct types\ne.g. Module or Base.TTY (the type of stdout)\nprimitive types\ne.g. Int64 or Float64\nUnions of types\ne.g. Union{Real, String} or Union{Module, Int64}\nThis also includes the empty Union{}\nUnionAlls over a type\ne.g. Array{T,N} where {T,N} or Val{N} where N\nThis family of types more-or-less works like an abstract type for our purposes.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"These five objects are our main point of interest. There are also some special types, like Type and DataType, but those are (for the most part) internal implementation details for giving some type to the type objects above, or are dispatch hacks and not relevant for this discussion.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"In general, these types are arranged in a lattice, formed by ordering according to <:, the subtype relation.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"This lattice has the following properties. The first five properties follow directly from being a lattice; the sixth is a result of our type system.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"For all types T, T <: Any is true.\nMore informally, Any is the topmost type in the lattice (thus also called Top).\nFor no types T other than T === Any does Any <: T hold.\nMore informally, the only supertype of Any is Any itself.\nFor all types T, Union{} <: T is true.\nMore informally, Union{} is the bottommost type in the lattice (thus also called Bottom).\nFor no types T other than T === Union{} does T <: Union{} hold.\nMore informally, the only subtype of Union{} is Union{}.\nFor all types T, T <: T is true.\nAll types are their own subtype.\nFor all types T, if isconcretetype(T) is true, then the only types S for which S <: T is true are S === Union{} and S === T.\nThis is the requirement that concrete types cannot be subtyped; they are (almost) direct supertypes of Union{}, though supertypes(Union{}) can't show us that (the set is not enumerable, because it grows with new struct & type definitions and UnionAlls make a mess of things through virtue of being infinitely large).\nNote that if !isconcretetype(T), this property has no effect - we can add a new abstract type below an existing abstract type, effectively inserting it inbetween Union{} <: T like Union{} <: S <: T.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"There are some other properties the type lattice has, but these are the ones relevant for this discussion, so we'll leave it at that. An informal description of the lattice is \"I can do potentially everything with an Any\", \"I can do nothing at all with a Union{}\" and \"I can do something with any type inbetween\". ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Stated differently, we can expect nothing in particular of an Any, we can expect exactly that we can't do anything with a Union{} and we can expect something of any type inbetween.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Stated yet differently, we don't get any guarantees from an object whose type we only know as Any, we get exactly the guarantee that we can do nothing from an object whose type we only know as Union{}, and we can expect some guarantees from objects whose type lies inbetween Any and Union{}.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"And stated yet differently, we can say that objects of type Any are minimally restrictive (they can do anything), objects of type Union{} are maximally restrictive (they can do nothing), and objects inbetween have some restriction.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"What we're interested in here is that something, and how it relates to the notion of an interface. For these purposes, UnionAlls behave exactly like abstract types (though with some additional features), so we're going to treat them as one entity.","category":"page"},{"location":"interfaces.html#Abstract-Types-and-Behavioral-Subtyping","page":"About Interfaces","title":"Abstract Types & Behavioral Subtyping","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Imagine we didn't have any types in our type lattice. It would look like this:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Union{} <: Any  ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"and that's it. If we now define a new abstract type Foo end, it's implicitly placed beneath Any:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Union{} <: Foo <: Any","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"just as if we had written abstract type Foo <: Any end instead.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"We can place more types, abstract type Bar <: Foo end, this time specifying Foo as the direct supertype. This results in this lattice:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Union{} <: Bar <: Foo <: Any","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Note that we still have Union{} <: Foo, either directly or by transitivity through Bar, due to Union{} <: Bar and Bar <: Foo both being true.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Imagine now we have a function:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myFunc(x::Any)\n    x\nend","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"which does nothing more than return its argument. The type signature annotates the argument x as Any, declaring to any caller \"I don't expect anything in particular from x, you can pass in anything\". ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Now, our subtyping declarations in our lattice communicate that objects of type Foo should dispatch in function calls just like Any does, so calling myFunc on an object of type Foo ought to work just the same as if the type were only Any. The same is true for Bar - we'd expect objects of type Bar to dispatch, and thus behave, the same as objects of all transitive supertypes. ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"The astute reader will have noticed a slight inaccuracy in the above - in Julia, we can't actually have any objects whose type is either Foo, Bar, Union{} or Any; every object has a concrete type, not an abstract, Union or even UnionAll type. If we now introduce a concrete type struct Concrete <: Bar end:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Union{} <: Concrete <: Bar <: Foo <: Any","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"We can truly say that objects of type Concrete ought to be possible to pass into myFunc, and  similarly any function that has an argument that's either unrestricted in its type or is explicitly typed Any. Said differently, any function which has arguments that are typed Any must not throw an error upon trying to call it with any object (though whether that call returns some form of a successful result is a different matter).","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"There are some implications with nesting function calls. For example, if we have a function myAdd:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myAdd(a,b)\n    a + b\nend    ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"our function may claim to accept anything, but the fact that we then call +(a,b) imposes an implicit constraint on both a and b - they are no longer truly typed Any, but rather a type that we can't describe in our lattice. We may say that a is typed \"Anything that can be used as the first argument to +\" and b is typed \"Anything that can be used as the second argument to +\". A priori, this is ok - when we put two Concrete objects into myAdd, the call to myAdd succeeds - it is only the call to + (which we haven't defined on Concrete, and no fallback actually accepting plain Any exists) that actually fails.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"So what we've effectively done is restrict the abstract types of a and b to conform to some interface, that is + must be defined on their types. We could encode this information in an abstract type, abstract type Addable end:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Union{} <: Addable <: Any","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"and annotate our myAdd with it, signaling to callers that they need to implement + in order to call myAdd:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myAdd(a::Addable, b::Addable)\n    a + b\nend ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"We've now successfully lifted the implicit requirement that + must be callable to myAdd, by restricting the argument types of myAdd. Effectively, (myFunc, +(::Addable, ::Addable)) form an interface, i.e. a function and the requirements for using that function. In type parlance, we may say \"myFunc has as preconditions on a and b that they subtype Addable\" as well as \"+ must implement a method that takes two Addable\".","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"In the context of this package (and more generally, Julia as a whole) though, the main players really are Addable and +, not myFunc. There's nothing we as users have to do to make myFunc work, once we have implemented + on our type T <: Addable, as that is the sole requirement needed to be able to call myFunc. The important thing is though, because we subtype Addable and thus claim to conform to the requirements of myFunc, we can treat the abstract type Addable itself as the interface we need to be concerned with, as far as dispatch and not throwing a MethodError goes. Thus, we can say that subtyping Addable is a statement of conformity to the requirements that Addable has, as well as an assurance that our type can give at least the same, if not stronger guarantees, as other types who subtype Addable can and/or need to be able to give.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Unfortunately, this kind of dependency is currently implicit in Julia. This is what @required allows a library to change - by making the expected interface explicit, implementors can check that they conform to the implicit interface that Addable or any other abstract type at minimum requires.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Note that this does not preclude Addable from being used in other functions; for example a third party package that's working with Addable objects may define a function like","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myThirdParty(::Addable)\n    println(\"Got an Addable\")\nend","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"and while the guarantees provided by the Addable interface/type (there is a method on + taking two Addable) are not actually used by myThirdParty, myThirdParty is free to require it anyway, without impacting what Addable requires of subtypes to implement in order to conform to its specification.","category":"page"},{"location":"interfaces.html#Unions-of-types","page":"About Interfaces","title":"Unions of types","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"A Union of types more or less communicates \"I can be one of these; assume only the intersection of their guarantees\". In a concrete example, if we have a function like","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myUnionFunc(sarr::Union{String,Vector{UInt8}})\n    length(sarr)\nend","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"we may only assume to be able to call functions that claim to be callable with objects of either type. In essence, a Union widens the possible values of sarr, by weakening the guarantees we get from the type. In order to write correct code, we mustn't assume more of sarr than we can infer from Union{String, Vector{UInt8}}, unless we guard that assumption behind either an explicit type check, or a function barrier that disambiguates the Union:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myUnionFunc(sarr::Union{String,Vector{UInt8}})\n    if sarr isa String\n        sarr *= '!'\n    else\n        push!(sarr, UInt8('!'))\n    end\nend","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"or","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"function myUnionFunc(sarr::Union{String,Vector{UInt8}})\n    pushpend!(sarr)\nend\n\npushpend!(s::String) = s*'!'\npushpend!(a::Vector{UInt8}) = push!(a, UInt8('!'))","category":"page"},{"location":"interfaces.html#Multiple-Abstract-Subtyping","page":"About Interfaces","title":"Multiple Abstract Subtyping","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Anyone cursorly familiar with abstract types and interfaces in Julia is going to come across the issue of wanting to implement more than one interface, and being able to communicate to others that they have done so. Most commonly, this comes up when implementing the AbstractArray interface, as well as the iteration interface - most types that wish to be treated like an AbstractArray are also iterable in one form or another. The situation can of course arise in any number of situations where more than one interface (or abstract type) needs to be implemented.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"This presents multiple issues:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"While AbstractArray can be subtyped, it may not always be desirable to do so, perhaps because there is some other guarantees that a package author wants to give of their objects and/or has multiple similar objects that should conform to the same interface, grouping them under a common abstract supertype.\nIf there are multiple possible \"variants\" of the abstract supertype that are not quite mutually exclusive, we can't easily communicate the requirements of those not-quite mutually exclusive subtypes through either abstract types.\nBarring being able to make the abstract supertype subtype AbstractArray (and by extension, the concrete subtypes as well), it won't be possible to subtype both AbstractArray and the custom abstract types at the same time.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"So what to do?","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"The currently most often used solution to this issue is a pattern called Holy Types, after Tim Holy, who first prototyped the design in this issue, trying to wrestle this exact issue for one of their types (only it was then DenseArray and StridedArray). It has seen a lot of use over the years, but is not without issues, which we're going to explore shortly.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"The general pattern goes like so; we first define an additional abstract type for our trait:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract type MyTrait end","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"followed by various variants of that trait, as well as some functions that decide whether an object supports this trait, falling back to not supporting it:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"struct IsTrait end\nstruct IsNotTrait end\n\nisMyTrait(_) = IsNotTrait()","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Now, instead of defining struct Foo <: MyTrait end and annotating our functions as ::MyTrait, we do the following:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"struct Foo end\n\nisMyTrait(::Foo) = IsTrait()\n\nmyInterfaceFunc(x) = _myInterfaceFunc(isMyTrait(x), x)\n\n_myInterfaceFunc(::IsTrait, x) = \"I implement the trait: $(typeof(x))\"\n_myInterfaceFunc(::IsNotTrait, x) = \"I don't implement the trait: $(typeof(x))\"","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"That is, leave the supertype declaration of Foo untyped, define an overload for the trait function isMyTrait(::Foo) to say we support the trait, and finally call that trait function in our entry function to dispatch later on to whether the argument supports the trait or not, and we're now free to have Foo subtype something else entirely.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"So instead of ","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract type MyTrait end\n\nstruct Foo <: MyTrait end\n\nmyInterfaceFunc(x::MyTrait) = \"I implement the interface\"","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"we have a layer of indirection, to be able to use dispatch while keeping Foo extensible to other interfaces.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"So if in the trait example we want to have Foo implement another interface via traits:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract type AnotherTrait end\n\nstruct IsAnother <: AnotherTrait end\nstruct IsNotAnother <: Anothertrait end\n\nisAnother(_) = IsNotAnother()\n\nisAnother(::Foo) = IsAnother()","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"we can easily do so, making this approach very extensible in terms of allowing Foo to implement more than one interface.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"As mentioned above though, there are downsides to this approach. First and foremost, if an interface has not been designed with this pattern in mind, there is no place for other packages to hook into for providing specialized versions for their own traits. That is, myInterfaceFunc needs to be written with this dispatch indirection of _myInterfaceFunc in mind. Worse, myInterfaceFunc only knows about isMyTrait; so at best we can extend MyTrait with new variants, but we cannot have myInterfaceFunc be aware of other traits without modifying the original function to either dispatch on more traits, or replacing isMyTrait with a sort of meta-trait for other traits to hook themselves into. None of this allows non-holy-traits based packages to be extended either way though.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"The \"way out\" I'm envisioning comes back around to remembering what the meaning of subtyping an abstract type is. Remember, when we subtype an abstract type we claim to give the same or stronger guarantees, and fulfill all requirements expected of us from the abstract type. So, under that consideration, it ought to be natural to be able to say that we can have types that declare a subtype relationship with more than one abstract super type, effectively saying that we fulfill the requirements of more than one abstract type. This isn't currently possible in Julia, but let's imagine it is and think about the consequences of what we might want to do.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Importantly, before we do - none of this means that these requirements & guaraantees are machine checkable or formally verified. Everything so far works just as well with \"lazy\" or only seperate checking of those requirements as it does with SAT based checking.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Without further ado, here's the MyTrait and AnotherTrait example from above. In order to facilitate multiple subtyping, we're going to introduce a new kind of type, the dual to Union - Meet.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"What is Meet? Well, in a lattice we can join different branches to find their common successor. This is Union - the common successor of String and Int (both concrete types) is Union{String,Int}, i.e. a type that describes either a String or an Int. Said differently, a Union describes an object of one of multiple types.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Meet is the dual to that - its the common predecessor in the lattice, describing that an object is of two or more types. For example, if we have a Meet{String, Int64} we'd be claiming to have an object that is both a String and an Int64. This may seem odd at first - after all, we can't actually have an object whose concrete type is both the concrete type String and the concrete type Int64, so that type contains no values, like the empty Union{}. However, once we consider creating the Meet of a number of abstract types, the interpretation makes a whole lot more sense - e.g. Meet{AbstractArray, Iterable} would mean \"A type that implements both the AbstractArray and Iterable interfaces\". This is exactly what we've been trying to do with Holy traits above. This allows us to fix the issues Holy Traits presented, at least partially:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract type MyTrait end\nabstract type AnotherTrait end\n\nstruct Foo <: Meet{MyTrait, AnotherTrait} end\n\nmyInterfaceFunc(::MyTrait) = \"I'm a MyTrait!\"\nanotherInterface(::AnotherTrait) = \"I'm AnotherTrait!\"","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"and both calls to myInterfaceFunc and anotherInterface succeed without issues when a Foo is put in, as a Foo is both a MyTrait, as well as a AnotherTrait. We can easily change Foo to implement a third interface, without touching that interface definition at all, by simply implementing its required (or perhaps even @required ;) ) methods and adding the interface type to the Meet in the struct declaration of Foo. This is even semver compatible - no existing functionality ought to break by doing this, since the existing interface must still be conformed to.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Similarly to the interpretation of Meet in structs, writing something like abstract type Foo <: Meet{Bar,Baz} end can be interpreted as \"subtypes of Foo need to implement/conform to both the Bar and Baz interfaces, as well as any additional guaraantees/requirements of Foo, if there are any\".","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Now, this isn't to say there aren't issues with Meet - for one, it doesn't allow third parties to extend the supported interfaces of Foo, because which interfaces Foo implements is part of its type definition. This is not an issue with Holy traits, due to their trait opt-in being disconnected from subtyping. This is the flipside of creating traits through dispatch, instead of through subtyping. However, how often this is actually needed/a good idea in practice is questionable - after all, since this is just regular dispatch, it's perfectly possible to just implement an interface on Foo directly, without explicitly subtyping the interface type. The only issue is that this doesn't scale all too well, due to the fact that third party code then too has to implement the interface explicitly for Foo, even if it could already be hooked into through dispatch, were Foo aware of that subtyping relationship. Maybe that's an argument for allowing modification of subtyping relationships after the type has been defined? My gut says that this is an even larger/more problematic change, which would be worked around by upstreaming the implementation of the new interface, if it's of general interest. Another alternative would be to couple the implicitness of the requirements imposed on abstract types closer to dispatch, allowing types that simply implement a required interface to dispatch as if they had declared that subtyping relationship in the first place.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Another argument I've previously heard against Meet was that it could increase ambiguities. For example:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract type MyTrait end\nabstract type AnotherTrait end\n\nstruct Foo <: Meet{MyTrait, AnotherTrait} end\n\nmyInterfaceFunc(::MyTrait) = \"I'm a MyTrait!\"\nmyInterfaceFunc(::AnotherTrait) = \"I'm AnotherTrait!\"","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"When calling myInterfaceFunc(Foo()), there will be an ambiguity error. If there are more arguments to myInterfaceFunc, there are many more opportunities for ambiguities. The only way to break this is to define either myInterfaceFunc(::Foo) or myInterfaceFunc(::Meet{MyTrait, AnotherTrait}).","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"My counterpoint to this is that we have exactly the same issue with Holy traits, except worse. There we can't even express this kind of relationship with the basic pattern. Consider the example from above again, introducing the Holy traits pattern:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"abstract type MyTrait end\nabstract type AnotherTrait end\n\nstruct IsMyTrait <: MyTrait end\nstruct IsNotMyTrait <: MyTrait end\n\nstruct IsAnother <: AnotherTrait end\nstruct IsNotAnother <: Anothertrait end\n\nisMyTrait(_) = IsNotMyTrait()\nisAnother(_) = IsNotAnother()\n\nisMyTrait(::Foo) = IsMyTrait()\nisAnother(::Foo) = IsAnother()\n\nmyInterfaceFunc(x) = _myInterfaceFunc(isMyTrait(x), x)","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Now, without modifying myInterfaceFunc, we can't define isMyTrait(::Foo) = IsAnotherTrait() to also support that kind of trait, because that would require giving up on MyTrait. We could introduce a second layer of indirection, to perhaps create a Meet-like of the supported traits, but that then exposes the true problem of the ambiguity between which implementation of _myInterfaceFunc we'd like to use, if both exist. The only way out is yet again defining _myInterfaceFunc(::Foo), breaking the ambiguity.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"In contrast, since both MyTrait and AnotherTrait share this trait function as part of their interface, Foo ought to have already been aware of the  ambiguity, and implemented to specialized version myInterfaceFunc(::Foo) itself directly (or fallen back to myInterfaceFunc(::Meet{MyTrait, AnotherTrait}), should that be available). The aambiguity needs to be broken some way or another, either by the Foo type for itself (it can't define the Meet version without piracy) or by either MyTrait or AnotherTrait via a package extension (ideally in coordinate, as otherwise you may get conflicting definitions overwriting each other).","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"All of this will need to be discussed & thought through thoroughly though - there is no silver bullet.","category":"page"},{"location":"interfaces.html#Relation-to-API-stability","page":"About Interfaces","title":"Relation to API stability","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"A related topic to \"Abstract types are (implicit) interfaces\" is how this interpretation relates to version changes under Semver. If an abstract type declares an (implicit) interface, it follows that changing that interface in a version bump requires considerations regarding stability, in order to not create a breaking change where none was intended. Specifically, if a non-breaking change is desired, at least the following must hold true:","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"A method that wasn't required to be implemented for subtypes must not become required to be implemented.\nThis is because adding a method to the required surface of the interface breaks existing implementations, by causing them to no longer be compliant with the interface.\nI.e., you can't \"grow\" an interface. If such an extension is desired, it is better to have a new abstract type subtyping the existing abstract type, with the additional requirements added to that subtype.\nA method that previously had certain requirements must not demand stronger requirements.\nThis again is because existing implementations may not be able to provide those stronger requirements.\nAn exception can be made if the newer, stronger requirements follow directly from the existing, weaker requirements; i.e. the \"stronger\" requirements were already there to begin with, but either undocumented or follow from deduction of the existing requirements.\nA method previously giving some set of guarantees can weaken those guarantees.\nThis is because existing implementations, who provide the older, stronger guarantees, will still be compliant with the interface.\nA method that was previously required in an interface, can not be made no longer required.\nThis is because code written with the old API surface and its assumptions of what names exist can break if it encounters a type working with the new surface, which may not implement a previously required method.\nI.e., you can't \"shrink\" an interface. If such a change is desired, the options are either\nto deprecate the functionality in a non-breaking change (being careful to keep existing code working!), and remove it in the next breaking change\nThis is easily coupled with moving a method to a subtype of the existing interface, directing users to subtype the subtype instead or by adding a direct supertype which has the weaker semantics (preferable, as that keeps user code the same).\nor to add a new, distinct type providing the smaller interface and deprecating the old interface entirely","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"There are certainly more details regarding interface stability between versions - this list is not exhaustive. An attempt at that exhaustiveness specific to Julia was recorded here, though there certainly is room for improvement and a more thorough calculus on what is permitted in terms of a change in API. There is also the possibility of incorporating existing literature into this (most I could find was in regards to empirical studies of API stability in Java, but even those results are bound to be useful). There is also some existing work from the rust community aabout this - see the references list down below.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Finally, the large body of work on preconditions, postconditions & invariants is also related to this topic.","category":"page"},{"location":"interfaces.html#Appendix","page":"About Interfaces","title":"Appendix","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"A large part of this discussion is inspired by looking at how other languages design their type system, but especially poignant (and what ultimately sparked my attempt here to equate abstract types with interfaces) was Abstract types have existential type, by Mitchell & Plotkin, 1988.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"It's a lucky coincidence that their work, combined with classic Liskov substitution and applied to the Julia type system has this somewhat clean interpretation of abstract types as interfaces just dropping out - in spite of multiple dispatch making things sometimes substantially harder. I attribute most of that lucky coincidence to the design choice not to have abstract types have structure, i.e. the lack of structural inheritance in Julia. Having abstract types only be relevant for dispatch means they map very cleanly to behavioral subtyping, as that is all they can express - they have no structure other than the implicit requirements placed on them by the functions they are passed to.","category":"page"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Admittedly, there are edge cases with Meet, in particular with how Meet and Union interact in dispatch, that I have not yet had the time to fully describe here. I do hope that their interactions fall cleanly out of the lattice geometry, though I haven't checked yet.","category":"page"},{"location":"interfaces.html#References","page":"About Interfaces","title":"References","text":"","category":"section"},{"location":"interfaces.html","page":"About Interfaces","title":"About Interfaces","text":"Tim Holy invents Holy traits\nAbstract types have existential type\nMeasuring software library stability through historical version analysis\nAPIDiff: Detecting API breaking changes\ncargo-semver-checks\ncargo-public-api","category":"page"},{"location":"examples/testing.html#Testing-Required-Interfaces","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"","category":"section"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"For example, consider a package B that would like to implement the interface from the previous section on its type MyImplementor:","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"module A # hide\nusing RequiredInterfaces # hide\nexport MyInterface, myfunc # hide\nabstract type MyInterface end # hide\nfunction myfunc end # hide\n@required MyInterface myfunc(::MyInterface) # hide\nend # hide\nusing .A # hide\nstruct MyImplementor <: MyInterface end\n\nA.myfunc(::MyImplementor) = \"Implemented!\"","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"The authors of package B would (rightly so) like to test that they have conformed to the interface, at least insofar that they are dispatching correctly. With RequiredInterfaces.jl, this too can be easily done (think of this next block as placed in runtests.jl):","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"using Test, RequiredInterfaces\nconst RI = RequiredInterfaces\n\n@test RI.check_interface_implemented(MyInterface, MyImplementor)","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"Compare this to what happens when a type doesn't implement the interface correctly:","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"struct NonImplementor <: MyInterface end\n@test RI.check_interface_implemented(MyInterface, NonImplementor)","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"check_interface_implemented not only detects that the interface wasn't fully implemented, it can also report which signature was missed, and for which function.","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"If there are a lot of types implementing a specific interface, it's also possible to test all types who claim to implement the interface, or only a subset of them, instead of doing that on per-type basis:","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"warning: Julia Bug\nThe first testset below should in reality produce an error, due to not all subtypes of MyInterface actually implementing the interface. However, due to a bug in Julia (see this issue), MyInterface claims to not have any subtypes, in spite of the fact that the subtypes have MyInterface as their supertype, leading to an empty testset. As a workaround, there is a second testset using the explicit collection version to check the subtypes manually, to show the expected failure. This bug in Julia should not impact the functionality of this package.","category":"page"},{"location":"examples/testing.html","page":"Testing Required Interfaces","title":"Testing Required Interfaces","text":"struct AnotherImplementor <: MyInterface end\nA.myfunc(::AnotherImplementor) = \"I'm different!\"\n@testset \"Test all subtypes\" RI.check_implementations(MyInterface);\n@testset \"Test all subtypes\" RI.check_implementations(MyInterface, [AnotherImplementor, MyImplementor, NonImplementor]);\n@testset \"Test subset\" RI.check_implementations(MyInterface, [AnotherImplementor, MyImplementor]);","category":"page"},{"location":"index.html#RequiredInterfaces.jl-Documentation","page":"Main Page","title":"RequiredInterfaces.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"This is the documentation for RequiredInterfaces.jl, a small package intended to mark the parts of an interface that implementors of that interface MUST implement in order to conform to it.","category":"page"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Check out the examples to get an introduction to interface specifications! If you're interested in the larger philosophy behind this package, check out the section About Interfaces.","category":"page"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Pages = [\"index.md\", \"examples/basic.md\", \"examples/testing.md\", \"interfaces.md\", \"api.md\"]\nDepth = 3","category":"page"},{"location":"index.html#Goals","page":"Main Page","title":"Goals","text":"","category":"section"},{"location":"index.html","page":"Main Page","title":"Main Page","text":"Giving interface-writers the ability to declare \"these are the required functions developers who would like to hook into this interface need to implement\".\nTreat abstract types like implicit interfaces.\nBe precompilation friendly & zero-overhead.\nAllow built-in testing for whether at least the required methods to conform to an interface are defined.","category":"page"},{"location":"examples/basic.html#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"Say we have a package that provides an interface for other packages to hook into:","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"module A\n\nexport MyInterface, myfunc\n\n\"\"\"\n    MyInterface\n\nI'm an abstract type, which means I have some required dispatches\nthat subtypes need to implement.\n\nThe interface to implement is:\n\n * myfunc(::MyInterface)\n\"\"\"\nabstract type MyInterface end\n\n\"\"\"\n    myfunc(::MyInterface)\n\nI'm the sole interface function for `MyInterface`. Types that subtype\n`MyInterface` must implement me on that subtype to conform to `MyInterface`.\n\"\"\"\nfunction myfunc end\nend","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"A priori, a potential implementor only has a docstring to go on, to be able to decide whether they've correctly implemented everything an interface requires to be implemented. Additionally, they can't easily write regression tests to ensure that they don't accidentally remove a required definition, or keep up with new additions to an interface in a breaking release of the interface they're depending on. This means keeping up with interface definitions is a quite tedious chore, even though all information ought to be available to (at least partially) automate this. What's worse, with just the bare function myfunc end definition above, it's impossible to tell \"this is unsupported\" apart from \"this is intended to be implemented\".","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"This is where RequiredInterfaces.jl comes in. If the above module makes use of @required to mark its interface requirementsi in terms of required dispatches, downstream packages that want to implement the interface can preemptively check if they've even defined the correct methods (and not have their implementation work by accident in an unsupported manner, e.g. by comitting type piracy or implementing an entirely different set of methods that just happen to work).","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"The change A has to make is simple:","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"module A\n\nusing RequiredInterfaces\n\nexport MyInterface, myfunc\n\n\"\"\"\n...omitted for brevity\n\"\"\"\nabstract type MyInterface end\n\n\"\"\"\n...omitted for brevity\n\"\"\"\nfunction myfunc end\n\n@required MyInterface myfunc(::MyInterface)\n\nend","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"That is, one additional using, as well as an invocation of @required with the abstract interface type as well as the function and its signature that's part of the interface MyInterface.","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"With this small change, all issues mentioned above are solvable. First, the ambiguity between \"should be implemented\" and \"not supported\" is solved:","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"using .A\nstruct Foo <: A.MyInterface end\nA.myfunc(Foo()) ","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"This is because @required defines a fallback method that dispatches to NotImplementedError, allowing users that encounter this error to notify the package maintainter that they have missed to implement a required method. Further, because this is an actually thrown error, it's also discoverable through JET.jl, even without explicit interface testing by implementors.","category":"page"},{"location":"examples/basic.html","page":"Basic Example","title":"Basic Example","text":"In the next section, we'll take a look at how package authors that would like to hook into an interface can test that they have successfully done so, at least in terms of defining the correct methods.","category":"page"}]
}
