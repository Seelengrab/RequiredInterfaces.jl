<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>About Interfaces · RequiredInterfaces.jl</title><meta name="title" content="About Interfaces · RequiredInterfaces.jl"/><meta property="og:title" content="About Interfaces · RequiredInterfaces.jl"/><meta property="twitter:title" content="About Interfaces · RequiredInterfaces.jl"/><meta name="description" content="Documentation for RequiredInterfaces.jl."/><meta property="og:description" content="Documentation for RequiredInterfaces.jl."/><meta property="twitter:description" content="Documentation for RequiredInterfaces.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">RequiredInterfaces.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Main Page</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/basic.html">Basic Example</a></li><li><a class="tocitem" href="examples/multifuncs.html">Interfaces with multiple functions</a></li><li><a class="tocitem" href="examples/testing.html">Testing Required Interfaces</a></li></ul></li><li class="is-active"><a class="tocitem" href="interfaces.html">About Interfaces</a><ul class="internal"><li><a class="tocitem" href="#Types-in-Julia"><span>Types in Julia</span></a></li><li><a class="tocitem" href="#Abstract-Types-and-Behavioral-Subtyping"><span>Abstract Types &amp; Behavioral Subtyping</span></a></li><li><a class="tocitem" href="#Multiple-Abstract-Subtyping"><span>Multiple Abstract Subtyping</span></a></li><li><a class="tocitem" href="#Relation-to-API-stability"><span>Relation to API stability</span></a></li><li><a class="tocitem" href="#Appendix"><span>Appendix</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="interfaces.html">About Interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="interfaces.html">About Interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Seelengrab/RequiredInterfaces.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Seelengrab/RequiredInterfaces.jl/blob/main/docs/src/interfaces.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="About-Interfaces"><a class="docs-heading-anchor" href="#About-Interfaces">About Interfaces</a><a id="About-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#About-Interfaces" title="Permalink"></a></h1><p>This package is built around the assumption that an abstract type describes an informal interface. In this page, we&#39;re going to look at why I think this is the expected interpretation for what an abstract type is, as well as what this means for the (possible) future of interfaces and traits.</p><h2 id="Types-in-Julia"><a class="docs-heading-anchor" href="#Types-in-Julia">Types in Julia</a><a id="Types-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Types-in-Julia" title="Permalink"></a></h2><p>Before we get into the semantic meaning of abstract types, it&#39;s good to establish a baseline about the kinds of types we have in Julia as part of the user facing API (deliberately <em>NOT</em> what the compiler internally uses!), how they relate to each other and what ought to hold in these relations.</p><p>So, these are the basic kinds of types Julia knows about:</p><ul><li><code>abstract</code> types<ul><li>e.g. <code>Integer</code> or <code>Real</code></li><li>This also includes the <code>Any</code> type</li></ul></li><li><code>struct</code> types<ul><li>e.g. <code>Module</code> or <code>Base.TTY</code> (the type of <code>stdout</code>)</li></ul></li><li><code>primitive</code> types<ul><li>e.g. <code>Int64</code> or <code>Float64</code></li></ul></li><li><code>Union</code>s of types<ul><li>e.g. <code>Union{Real, String}</code> or <code>Union{Module, Int64}</code></li><li>This also includes the empty <code>Union{}</code></li></ul></li><li><code>UnionAll</code>s over a type<ul><li>e.g. <code>Array{T,N} where {T,N}</code> or <code>Val{N} where N</code></li><li>This family of types more-or-less works like an abstract type for our purposes.</li></ul></li></ul><p>These five objects are our main point of interest. There are also some special types, like <code>Type</code> and <code>DataType</code>, but those are (for the most part) internal implementation details for giving some type to the type objects above, or are dispatch hacks and not relevant for this discussion.</p><p>In general, these types are arranged in a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a>, formed by ordering according to <code>&lt;:</code>, the subtype relation.</p><p>This lattice has the following properties. The first five properties follow directly from being a lattice; the sixth is a result of our type system.</p><ul><li>For all types <code>T</code>, <code>T &lt;: Any</code> is <code>true</code>.<ul><li>More informally, <code>Any</code> is the topmost type in the lattice (thus also called Top).</li></ul></li><li>For no types <code>T</code> other than <code>T === Any</code> does <code>Any &lt;: T</code> hold.<ul><li>More informally, the only supertype of <code>Any</code> is <code>Any</code> itself.</li></ul></li><li>For all types <code>T</code>, <code>Union{} &lt;: T</code> is <code>true</code>.<ul><li>More informally, <code>Union{}</code> is the bottommost type in the lattice (thus also called Bottom).</li></ul></li><li>For no types <code>T</code> other than <code>T === Union{}</code> does <code>T &lt;: Union{}</code> hold.<ul><li>More informally, the only subtype of <code>Union{}</code> is <code>Union{}</code>.</li></ul></li><li>For all types <code>T</code>, <code>T &lt;: T</code> is <code>true</code>.<ul><li>All types are their own subtype.</li></ul></li><li>For all types <code>T</code>, if <code>isconcretetype(T)</code> is <code>true</code>, then the only types <code>S</code> for which <code>S &lt;: T</code> is <code>true</code> are <code>S === Union{}</code> and <code>S === T</code>.<ul><li>This is the requirement that concrete types cannot be subtyped; they are (almost) direct supertypes of <code>Union{}</code>, though <code>supertypes(Union{})</code> can&#39;t show us that (the set is not enumerable, because it grows with new struct &amp; type definitions and <code>UnionAll</code>s make a mess of things through virtue of being infinitely large).</li><li>Note that if <code>!isconcretetype(T)</code>, this property has no effect - we can add a new abstract type below an existing abstract type, effectively inserting it inbetween <code>Union{} &lt;: T</code> like <code>Union{} &lt;: S &lt;: T</code>.</li></ul></li></ul><p>There are some other properties the type lattice has, but these are the ones relevant for this discussion, so we&#39;ll leave it at that. An informal description of the lattice is &quot;I can do potentially everything with an <code>Any</code>&quot;, &quot;I can do nothing at all with a <code>Union{}</code>&quot; and &quot;I can do <em>something</em> with any type inbetween&quot;. </p><p>Stated differently, we can expect nothing in particular of an <code>Any</code>, we can expect <strong>exactly</strong> that we can&#39;t do anything with a <code>Union{}</code> and we can expect <em>something</em> of any type inbetween.</p><p>Stated yet differently, we don&#39;t get any guarantees from an object whose type we only know as <code>Any</code>, we get <strong>exactly</strong> the guarantee that we can do nothing from an object whose type we only know as <code>Union{}</code>, and we can expect <em>some</em> guarantees from objects whose type lies inbetween <code>Any</code> and <code>Union{}</code>.</p><p>And stated yet differently, we can say that objects of type <code>Any</code> are minimally restrictive (they can do anything), objects of type <code>Union{}</code> are maximally restrictive (they can do nothing), and objects inbetween have <em>some</em> restriction.</p><p>What we&#39;re interested in here is that <em>something</em>, and how it relates to the notion of an interface. For these purposes, <code>UnionAll</code>s behave exactly like abstract types (though with some additional features), so we&#39;re going to treat them as one entity.</p><h2 id="Abstract-Types-and-Behavioral-Subtyping"><a class="docs-heading-anchor" href="#Abstract-Types-and-Behavioral-Subtyping">Abstract Types &amp; Behavioral Subtyping</a><a id="Abstract-Types-and-Behavioral-Subtyping-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types-and-Behavioral-Subtyping" title="Permalink"></a></h2><p>Imagine we didn&#39;t have any types in our type lattice. It would look like this:</p><pre><code class="language-julia hljs">Union{} &lt;: Any  </code></pre><p>and that&#39;s it. If we now define a new <code>abstract type Foo end</code>, it&#39;s implicitly placed beneath <code>Any</code>:</p><pre><code class="language-julia hljs">Union{} &lt;: Foo &lt;: Any</code></pre><p>just as if we had written <code>abstract type Foo &lt;: Any end</code> instead.</p><p>We can place more types, <code>abstract type Bar &lt;: Foo end</code>, this time specifying <code>Foo</code> as the direct supertype. This results in this lattice:</p><pre><code class="language-julia hljs">Union{} &lt;: Bar &lt;: Foo &lt;: Any</code></pre><p>Note that we still have <code>Union{} &lt;: Foo</code>, either directly or by transitivity through <code>Bar</code>, due to <code>Union{} &lt;: Bar</code> and <code>Bar &lt;: Foo</code> both being true.</p><p>Imagine now we have a function:</p><pre><code class="language-julia hljs">function myFunc(x::Any)
    x
end</code></pre><p>which does nothing more than return its argument. The type signature annotates the argument <code>x</code> as <code>Any</code>, declaring to any caller &quot;I don&#39;t expect anything in particular from <code>x</code>, you can pass in anything&quot;. </p><p>Now, our subtyping declarations in our lattice communicate that objects of type <code>Foo</code> should dispatch in function calls just like <code>Any</code> does, so calling <code>myFunc</code> on an object of type <code>Foo</code> ought to work just the same as if the type were only <code>Any</code>. The same is true for <code>Bar</code> - we&#39;d expect objects of type <code>Bar</code> to dispatch, and thus behave, the same as objects of all transitive supertypes. </p><p>The astute reader will have noticed a slight inaccuracy in the above - in Julia, we can&#39;t actually have any objects whose type is either <code>Foo</code>, <code>Bar</code>, <code>Union{}</code> or <code>Any</code>; every object has a concrete type, not an abstract, <code>Union</code> or even <code>UnionAll</code> type. If we now introduce a concrete type <code>struct Concrete &lt;: Bar end</code>:</p><pre><code class="language-julia hljs">Union{} &lt;: Concrete &lt;: Bar &lt;: Foo &lt;: Any</code></pre><p>We can truly say that objects of type <code>Concrete</code> ought to be possible to pass into <code>myFunc</code>, and  similarly any function that has an argument that&#39;s either unrestricted in its type or is explicitly typed <code>Any</code>. Said differently, any function which has arguments that are typed <code>Any</code> must not throw an error upon trying to call it with any object (though whether that call returns some form of a successful result is a different matter).</p><p>There are some implications with nesting function calls. For example, if we have a function <code>myAdd</code>:</p><pre><code class="language-julia hljs">function myAdd(a,b)
    a + b
end    </code></pre><p>our function may <em>claim</em> to accept anything, but the fact that we then call <code>+(a,b)</code> imposes an implicit constraint on both <code>a</code> and <code>b</code> - they are no longer truly typed <code>Any</code>, but rather a type that we can&#39;t describe in our lattice. We may say that <code>a</code> is typed &quot;Anything that can be used as the first argument to <code>+</code>&quot; and <code>b</code> is typed &quot;Anything that can be used as the second argument to <code>+</code>&quot;. A priori, this is ok - when we put two <code>Concrete</code> objects into <code>myAdd</code>, the call to <code>myAdd</code> succeeds - it is only the call to <code>+</code> (which we haven&#39;t defined on <code>Concrete</code>, and no fallback actually accepting plain <code>Any</code> exists) that actually fails.</p><p>So what we&#39;ve effectively done is <em>restrict</em> the abstract types of <code>a</code> and <code>b</code> to conform to some interface, that is <code>+</code> must be defined on their types. We could encode this information in an abstract type, <code>abstract type Addable end</code>:</p><pre><code class="language-julia hljs">Union{} &lt;: Addable &lt;: Any</code></pre><p>and annotate our <code>myAdd</code> with it, signaling to callers that they need to implement <code>+</code> in order to call <code>myAdd</code>:</p><pre><code class="language-julia hljs">function myAdd(a::Addable, b::Addable)
    a + b
end </code></pre><p>We&#39;ve now successfully lifted the implicit requirement that <code>+</code> must be callable to <code>myAdd</code>, by restricting the argument types of <code>myAdd</code>. Effectively, <code>(myFunc, +(::Addable, ::Addable))</code> form an interface, i.e. a function and the requirements for using that function. In type parlance, we may say &quot;<code>myFunc</code> has as preconditions on <code>a</code> and <code>b</code> that they subtype <code>Addable</code>&quot; as well as &quot;<code>+</code> must implement a method that takes two <code>Addable</code>&quot;.</p><p>In the context of this package (and more generally, Julia as a whole) though, the main players really are <code>Addable</code> and <code>+</code>, not <code>myFunc</code>. There&#39;s nothing we as users have to do to make <code>myFunc</code> work, once we have implemented <code>+</code> on our type <code>T &lt;: Addable</code>, as that is the sole requirement needed to be able to call <code>myFunc</code>. The important thing is though, because we subtype <code>Addable</code> and thus claim to conform to the requirements of <code>myFunc</code>, we can treat the abstract type <code>Addable</code> <em>itself</em> as the interface we need to be concerned with, as far as dispatch and not throwing a <code>MethodError</code> goes. Thus, we can say that subtyping <code>Addable</code> is a statement of conformity to the requirements that <code>Addable</code> has, as well as an assurance that our type can give at least the same, if not stronger guarantees, as other types who subtype <code>Addable</code> can and/or need to be able to give.</p><p>Unfortunately, this kind of dependency is currently implicit in Julia. This is what <a href="api.html#RequiredInterfaces.@required-Tuple{Symbol, Expr}"><code>@required</code></a> allows a library to change - by making the expected interface explicit, implementors can <em>check</em> that they conform to the implicit interface that <code>Addable</code> or any other abstract type at minimum requires.</p><p>Note that this does not preclude <code>Addable</code> from being used in other functions; for example a third party package that&#39;s working with <code>Addable</code> objects may define a function like</p><pre><code class="language-julia hljs">function myThirdParty(::Addable)
    println(&quot;Got an Addable&quot;)
end</code></pre><p>and while the guarantees provided by the <code>Addable</code> interface/type (there is a method on <code>+</code> taking two <code>Addable</code>) are not actually used by <code>myThirdParty</code>, <code>myThirdParty</code> is free to require it anyway, without impacting what <code>Addable</code> requires of subtypes to implement in order to conform to its specification.</p><h3 id="Unions-of-types"><a class="docs-heading-anchor" href="#Unions-of-types"><code>Union</code>s of types</a><a id="Unions-of-types-1"></a><a class="docs-heading-anchor-permalink" href="#Unions-of-types" title="Permalink"></a></h3><p>A <code>Union</code> of types more or less communicates &quot;I can be one of these; assume only the intersection of their guarantees&quot;. In a concrete example, if we have a function like</p><pre><code class="language-julia hljs">function myUnionFunc(sarr::Union{String,Vector{UInt8}})
    length(sarr)
end</code></pre><p>we may only assume to be able to call functions that claim to be callable with objects of either type. In essence, a <code>Union</code> widens the possible values of <code>sarr</code>, by weakening the guarantees we get from the type. In order to write correct code, we mustn&#39;t assume more of <code>sarr</code> than we can infer from <code>Union{String, Vector{UInt8}}</code>, unless we guard that assumption behind either an explicit type check, or a function barrier that disambiguates the <code>Union</code>:</p><pre><code class="language-julia hljs">function myUnionFunc(sarr::Union{String,Vector{UInt8}})
    if sarr isa String
        sarr *= &#39;!&#39;
    else
        push!(sarr, UInt8(&#39;!&#39;))
    end
end</code></pre><p>or</p><pre><code class="language-julia hljs">function myUnionFunc(sarr::Union{String,Vector{UInt8}})
    pushpend!(sarr)
end

pushpend!(s::String) = s*&#39;!&#39;
pushpend!(a::Vector{UInt8}) = push!(a, UInt8(&#39;!&#39;))</code></pre><h2 id="Multiple-Abstract-Subtyping"><a class="docs-heading-anchor" href="#Multiple-Abstract-Subtyping">Multiple Abstract Subtyping</a><a id="Multiple-Abstract-Subtyping-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Abstract-Subtyping" title="Permalink"></a></h2><p>Anyone cursorly familiar with abstract types and interfaces in Julia is going to come across the issue of wanting to implement more than one interface, and being able to communicate to others that they have done so. Most commonly, this comes up when implementing the <code>AbstractArray</code> interface, as well as the iteration interface - most types that wish to be treated like an <code>AbstractArray</code> are also iterable in one form or another. The situation can of course arise in any number of situations where more than one interface (or abstract type) needs to be implemented.</p><p>This presents multiple issues:</p><ul><li>While <code>AbstractArray</code> can be subtyped, it may not always be desirable to do so, perhaps because there is some other guarantees that a package author wants to give of their objects and/or has multiple similar objects that should conform to the same interface, grouping them under a common abstract supertype.</li><li>If there are multiple possible &quot;variants&quot; of the abstract supertype that are not quite mutually exclusive, we can&#39;t easily communicate the requirements of those not-quite mutually exclusive subtypes through either abstract types.</li><li>Barring being able to make the abstract supertype subtype <code>AbstractArray</code> (and by extension, the concrete subtypes as well), it won&#39;t be possible to subtype both <code>AbstractArray</code> and the custom abstract types at the same time.</li></ul><p>So what to do?</p><p>The currently most often used solution to this issue is a pattern called Holy Types, after Tim Holy, who first prototyped the design in <a href="https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633">this issue</a>, trying to wrestle this exact issue for one of their types (only it was then <code>DenseArray</code> and <code>StridedArray</code>). It has seen a lot of use over the years, but is not without issues, which we&#39;re going to explore shortly.</p><p>The general pattern goes like so; we first define an additional abstract type for our trait:</p><pre><code class="language-julia hljs">abstract type MyTrait end</code></pre><p>followed by various variants of that trait, as well as some functions that decide whether an object supports this trait, falling back to not supporting it:</p><pre><code class="language-julia hljs">struct IsTrait end
struct IsNotTrait end

isMyTrait(_) = IsNotTrait()</code></pre><p>Now, instead of defining <code>struct Foo &lt;: MyTrait end</code> and annotating our functions as <code>::MyTrait</code>, we do the following:</p><pre><code class="language-julia hljs">struct Foo end

isMyTrait(::Foo) = IsTrait()

myInterfaceFunc(x) = _myInterfaceFunc(isMyTrait(x), x)

_myInterfaceFunc(::IsTrait, x) = &quot;I implement the trait: $(typeof(x))&quot;
_myInterfaceFunc(::IsNotTrait, x) = &quot;I don&#39;t implement the trait: $(typeof(x))&quot;</code></pre><p>That is, leave the supertype declaration of <code>Foo</code> untyped, define an overload for the trait function <code>isMyTrait(::Foo)</code> to say we support the trait, and finally call that trait function in our entry function to dispatch later on to whether the argument supports the trait or not, and we&#39;re now free to have <code>Foo</code> subtype something else entirely.</p><p>So instead of </p><pre><code class="language-julia hljs">abstract type MyTrait end

struct Foo &lt;: MyTrait end

myInterfaceFunc(x::MyTrait) = &quot;I implement the interface&quot;</code></pre><p>we have a layer of indirection, to be able to use dispatch while keeping <code>Foo</code> extensible to other interfaces.</p><p>So if in the trait example we want to have <code>Foo</code> implement another interface via traits:</p><pre><code class="language-julia hljs">abstract type AnotherTrait end

struct IsAnother &lt;: AnotherTrait end
struct IsNotAnother &lt;: Anothertrait end

isAnother(_) = IsNotAnother()

isAnother(::Foo) = IsAnother()</code></pre><p>we can easily do so, making this approach very extensible in terms of allowing <code>Foo</code> to implement more than one interface.</p><p>As mentioned above though, there are downsides to this approach. First and foremost, if an interface has not been designed with this pattern in mind, there is no place for other packages to hook into for providing specialized versions for their own traits. That is, <code>myInterfaceFunc</code> needs to be written with this dispatch indirection of <code>_myInterfaceFunc</code> in mind. Worse, <code>myInterfaceFunc</code> only knows about <code>isMyTrait</code>; so at best we can extend <code>MyTrait</code> with new variants, but we cannot have <code>myInterfaceFunc</code> be aware of other traits without modifying the original function to either dispatch on more traits, or replacing <code>isMyTrait</code> with a sort of meta-trait for other traits to hook themselves into. None of this allows non-holy-traits based packages to be extended either way though.</p><p>The &quot;way out&quot; I&#39;m envisioning comes back around to remembering what the meaning of subtyping an abstract type is. Remember, when we subtype an abstract type we claim to give the same or stronger guarantees, and fulfill all requirements expected of us from the abstract type. So, under that consideration, it ought to be natural to be able to say that we can have types that declare a subtype relationship with more than one abstract super type, effectively saying that we fulfill the requirements of more than one abstract type. This isn&#39;t currently possible in Julia, but let&#39;s imagine it is and think about the consequences of what we might want to do.</p><p>Importantly, before we do - none of this means that these requirements &amp; guaraantees are machine checkable or formally verified. Everything so far works just as well with &quot;lazy&quot; or only seperate checking of those requirements as it does with SAT based checking.</p><p>Without further ado, here&#39;s the <code>MyTrait</code> and <code>AnotherTrait</code> example from above. In order to facilitate multiple subtyping, we&#39;re going to introduce a new kind of type, the dual to <code>Union</code> - <code>Meet</code>.</p><p>What is <code>Meet</code>? Well, in a lattice we can join different branches to find their common successor. This is <code>Union</code> - the common successor of <code>String</code> and <code>Int</code> (both concrete types) is <code>Union{String,Int}</code>, i.e. a type that describes either a <code>String</code> or an <code>Int</code>. Said differently, a <code>Union</code> describes an object of one of multiple types.</p><p><code>Meet</code> is the dual to that - its the common predecessor in the lattice, describing that an object is of two or more types. For example, if we have a <code>Meet{String, Int64}</code> we&#39;d be claiming to have an object that is both a <code>String</code> and an <code>Int64</code>. This may seem odd at first - after all, we can&#39;t actually have an object whose concrete type is both the concrete type <code>String</code> and the concrete type <code>Int64</code>, so that type contains no values, like the empty <code>Union{}</code>. However, once we consider creating the <code>Meet</code> of a number of abstract types, the interpretation makes a whole lot more sense - e.g. <code>Meet{AbstractArray, Iterable}</code> would mean &quot;A type that implements both the <code>AbstractArray</code> and <code>Iterable</code> interfaces&quot;. This is exactly what we&#39;ve been trying to do with Holy traits above. This allows us to fix the issues Holy Traits presented, at least partially:</p><pre><code class="language-julia hljs">abstract type MyTrait end
abstract type AnotherTrait end

struct Foo &lt;: Meet{MyTrait, AnotherTrait} end

myInterfaceFunc(::MyTrait) = &quot;I&#39;m a MyTrait!&quot;
anotherInterface(::AnotherTrait) = &quot;I&#39;m AnotherTrait!&quot;</code></pre><p>and both calls to <code>myInterfaceFunc</code> and <code>anotherInterface</code> succeed without issues when a <code>Foo</code> is put in, as a <code>Foo</code> is both a <code>MyTrait</code>, as well as a <code>AnotherTrait</code>. We can easily change <code>Foo</code> to implement a third interface, without touching that interface definition at all, by simply implementing its required (or perhaps even <a href="api.html#RequiredInterfaces.@required-Tuple{Symbol, Expr}"><code>@required</code></a> ;) ) methods and adding the interface type to the <code>Meet</code> in the struct declaration of <code>Foo</code>. This is even semver compatible - no existing functionality ought to break by doing this, since the existing interface must still be conformed to.</p><p>Similarly to the interpretation of <code>Meet</code> in structs, writing something like <code>abstract type Foo &lt;: Meet{Bar,Baz} end</code> can be interpreted as &quot;subtypes of <code>Foo</code> need to implement/conform to both the <code>Bar</code> and <code>Baz</code> interfaces, as well as any additional guaraantees/requirements of <code>Foo</code>, if there are any&quot;.</p><p>Now, this isn&#39;t to say there aren&#39;t issues with <code>Meet</code> - for one, it doesn&#39;t allow third parties to extend the supported interfaces of <code>Foo</code>, because which interfaces <code>Foo</code> implements is part of its type definition. This is not an issue with Holy traits, due to their trait opt-in being disconnected from subtyping. This is the flipside of creating traits through dispatch, instead of through subtyping. However, how often this is actually needed/a good idea in practice is questionable - after all, since this is just regular dispatch, it&#39;s perfectly possible to just implement an interface on <code>Foo</code> directly, without explicitly subtyping the interface type. The only issue is that this doesn&#39;t scale all too well, due to the fact that third party code then too has to implement the interface explicitly for <code>Foo</code>, even if it could already be hooked into through dispatch, were <code>Foo</code> aware of that subtyping relationship. Maybe that&#39;s an argument for allowing modification of subtyping relationships after the type has been defined? My gut says that this is an even larger/more problematic change, which would be worked around by upstreaming the implementation of the new interface, if it&#39;s of general interest. Another alternative would be to couple the implicitness of the requirements imposed on abstract types closer to dispatch, allowing types that simply implement a required interface to dispatch as if they had declared that subtyping relationship in the first place.</p><p>Another argument I&#39;ve previously heard against <code>Meet</code> was that it could increase ambiguities. For example:</p><pre><code class="language-julia hljs">abstract type MyTrait end
abstract type AnotherTrait end

struct Foo &lt;: Meet{MyTrait, AnotherTrait} end

myInterfaceFunc(::MyTrait) = &quot;I&#39;m a MyTrait!&quot;
myInterfaceFunc(::AnotherTrait) = &quot;I&#39;m AnotherTrait!&quot;</code></pre><p>When calling <code>myInterfaceFunc(Foo())</code>, there will be an ambiguity error. If there are more arguments to <code>myInterfaceFunc</code>, there are many more opportunities for ambiguities. The only way to break this is to define either <code>myInterfaceFunc(::Foo)</code> or <code>myInterfaceFunc(::Meet{MyTrait, AnotherTrait})</code>.</p><p>My counterpoint to this is that we have exactly the same issue with Holy traits, except worse. There we can&#39;t even express this kind of relationship with the basic pattern. Consider the example from above again, introducing the Holy traits pattern:</p><pre><code class="language-julia hljs">abstract type MyTrait end
abstract type AnotherTrait end

struct IsMyTrait &lt;: MyTrait end
struct IsNotMyTrait &lt;: MyTrait end

struct IsAnother &lt;: AnotherTrait end
struct IsNotAnother &lt;: Anothertrait end

isMyTrait(_) = IsNotMyTrait()
isAnother(_) = IsNotAnother()

isMyTrait(::Foo) = IsMyTrait()
isAnother(::Foo) = IsAnother()

myInterfaceFunc(x) = _myInterfaceFunc(isMyTrait(x), x)</code></pre><p>Now, without modifying <code>myInterfaceFunc</code>, we can&#39;t define <code>isMyTrait(::Foo) = IsAnotherTrait()</code> to also support that kind of trait, because that would require giving up on <code>MyTrait</code>. We could introduce a second layer of indirection, to perhaps create a <code>Meet</code>-like of the supported traits, but that then exposes the true problem of the ambiguity between which implementation of <code>_myInterfaceFunc</code> we&#39;d like to use, if both exist. The only way out is yet again defining <code>_myInterfaceFunc(::Foo)</code>, breaking the ambiguity.</p><p>In contrast, since both <code>MyTrait</code> and <code>AnotherTrait</code> share this trait function as part of their interface, <code>Foo</code> ought to have already been aware of the  ambiguity, and implemented to specialized version <code>myInterfaceFunc(::Foo)</code> itself directly (or fallen back to <code>myInterfaceFunc(::Meet{MyTrait, AnotherTrait})</code>, should that be available). The aambiguity needs to be broken some way or another, either by the <code>Foo</code> type for itself (it can&#39;t define the <code>Meet</code> version without piracy) or by either <code>MyTrait</code> or <code>AnotherTrait</code> via a package extension (ideally in coordinate, as otherwise you may get conflicting definitions overwriting each other).</p><p>All of this will need to be discussed &amp; thought through thoroughly though - there is no silver bullet.</p><h2 id="Relation-to-API-stability"><a class="docs-heading-anchor" href="#Relation-to-API-stability">Relation to API stability</a><a id="Relation-to-API-stability-1"></a><a class="docs-heading-anchor-permalink" href="#Relation-to-API-stability" title="Permalink"></a></h2><p>A related topic to &quot;Abstract types are (implicit) interfaces&quot; is how this interpretation relates to version changes under Semver. If an abstract type declares an (implicit) interface, it follows that changing that interface in a version bump requires considerations regarding stability, in order to not create a breaking change where none was intended. Specifically, if a non-breaking change is desired, at least the following must hold true:</p><ul><li>A method that <strong>wasn&#39;t</strong> required to be implemented for subtypes must not become required to be implemented.<ul><li>This is because adding a method to the required surface of the interface breaks existing implementations, by causing them to no longer be compliant with the interface.</li><li>I.e., you can&#39;t &quot;grow&quot; an interface. If such an extension is desired, it is better to have a new abstract type subtyping the existing abstract type, with the additional requirements added to that subtype.</li></ul></li><li>A method that previously had certain requirements <strong>must not</strong> demand stronger requirements.<ul><li>This again is because existing implementations may not be able to provide those stronger requirements.</li><li>An exception can be made if the newer, stronger requirements follow directly from the existing, weaker requirements; i.e. the &quot;stronger&quot; requirements were already there to begin with, but either undocumented or follow from deduction of the existing requirements.</li></ul></li><li>A method previously giving some set of guarantees <strong>can</strong> weaken those guarantees.<ul><li>This is because existing implementations, who provide the older, stronger guarantees, will still be compliant with the interface.</li></ul></li><li>A method that was previously required in an interface, <strong>can not</strong> be made no longer required.<ul><li>This is because code written with the old API surface and its assumptions of what names exist can break if it encounters a type working with the new surface, which may not implement a previously required method.</li><li>I.e., you can&#39;t &quot;shrink&quot; an interface. If such a change is desired, the options are either<ul><li>to deprecate the functionality in a non-breaking change (being careful to keep existing code working!), and remove it in the next breaking change<ul><li>This is easily coupled with moving a method to a subtype of the existing interface, directing users to subtype the subtype instead or by adding a direct supertype which has the weaker semantics (preferable, as that keeps user code the same).</li></ul></li><li>or to add a new, distinct type providing the smaller interface and deprecating the old interface entirely</li></ul></li></ul></li></ul><p>There are certainly more details regarding interface stability between versions - this list is not exhaustive. An attempt at that exhaustiveness specific to Julia was recorded <a href="https://github.com/JuliaLang/julia/issues/49973">here</a>, though there certainly is room for improvement and a more thorough calculus on what is permitted in terms of a change in API. There is also the possibility of incorporating existing literature into this (most I could find was in regards to empirical studies of API stability in Java, but even those results are bound to be useful). There is also some existing work from the rust community aabout this - see the references list down below.</p><p>Finally, the large body of work on preconditions, postconditions &amp; invariants is also related to this topic.</p><h2 id="Appendix"><a class="docs-heading-anchor" href="#Appendix">Appendix</a><a id="Appendix-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix" title="Permalink"></a></h2><p>A large part of this discussion is inspired by looking at how other languages design their type system, but especially poignant (and what ultimately sparked my attempt here to equate abstract types with interfaces) was <a href="https://dl.acm.org/doi/10.1145/44501.45065">Abstract types have existential type</a>, by Mitchell &amp; Plotkin, 1988.</p><p>It&#39;s a lucky coincidence that their work, combined with classic Liskov substitution and applied to the Julia type system has this somewhat clean interpretation of abstract types as interfaces just dropping out - in spite of multiple dispatch making things sometimes substantially harder. I attribute most of that lucky coincidence to the design choice not to have abstract types have structure, i.e. the lack of structural inheritance in Julia. Having abstract types only be relevant for dispatch means they map very cleanly to behavioral subtyping, as that is all they can express - they have no structure other than the implicit requirements placed on them by the functions they are passed to.</p><p>Admittedly, there are edge cases with <code>Meet</code>, in particular with how <code>Meet</code> and <code>Union</code> interact in dispatch, that I have not yet had the time to fully describe here. I do hope that their interactions fall cleanly out of the lattice geometry, though I haven&#39;t checked yet.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li><a href="https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633">Tim Holy invents Holy traits</a></li><li><a href="https://dl.acm.org/doi/10.1145/44501.45065">Abstract types have existential type</a></li><li><a href="https://ieeexplore.ieee.org/abstract/document/6405296">Measuring software library stability through historical version analysis</a></li><li><a href="https://ieeexplore.ieee.org/abstract/document/8330249">APIDiff: Detecting API breaking changes</a></li><li><a href="https://github.com/obi1kenobi/cargo-semver-checks">cargo-semver-checks</a></li><li><a href="https://github.com/Enselic/cargo-public-api">cargo-public-api</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples/testing.html">« Testing Required Interfaces</a><a class="docs-footer-nextpage" href="api.html">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 4 April 2024 02:30">Thursday 4 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
